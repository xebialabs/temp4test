apply plugin: 'java'
apply plugin: 'eclipse'

Properties versionProps = new Properties()
file('version.properties').withReader { r ->
  versionProps.load(r)
  version = versionProps.get('version')
}

repositories {
  mavenLocal()
  mavenCentral()
  maven {
    url "$nexusBaseUrl/repositories/releases"
    credentials {
      username nexusUserName
      password nexusPassword
    }
  }
}

buildscript {
  repositories { mavenCentral() }
  dependencies {
    classpath 'org.eclipse.jgit:org.eclipse.jgit:2.0.0.201206130900-r'
    classpath 'com.typesafe:config:1.2.0'
  }
}

configurations {
  // configuration used by plugins to enumerate jars that need to be added to the distribution zip
  distBundle
}

dependencies {
  compile 'org.eclipse.jgit:org.eclipse.jgit:2.0.0.201206130900-r'
  // snapshot for testing
  compile 'com.xebialabs.deployit:engine-api:4.0.1-SNAPSHOT'
  // alpha for testing
  compile 'com.xebialabs.deployit:engine-spi:4.1.0-alpha-1'

  // 
  distBundle 'com.xebialabs.deployit:engine-api:4.0.1-SNAPSHOT'
  // alpha for testing
  distBundle 'com.xebialabs.deployit:engine-spi:4.1.0-alpha-1'
}

gradle.taskGraph.whenReady { taskGraph ->
  // append snapshot for non release builds
  if (!taskGraph.hasTask(':releaseMinor')) {
    version += '-SNAPSHOT'
  }
  // TODO: for alpha we could append alpha and read the alpha number from a file
}

task distribution << {
  println "Building distribution (pretend)"
}

task checkRepositoryIsClean(type: CheckRepoClean) {
  description = 'Check that the git repository is clean.'
  dryRun = true
  group = 'Verification'
  gitDir = project.file(project.rootProject.projectDir.path + "/.git")
  if (!gitDir.exists()) {
    throw GradleException("Cannot release from a non version controlled tree.")
  }
}

task checkReleaseTagIsAbsent(type: CheckTagAbsent) {
  tag = { -> "${project.name}-${project.version}" }
  description = "Check that the release tag is absent."
  group = 'Release'
  gitDir = project.file(project.rootProject.projectDir.path + "/.git")
  if (!gitDir.exists()) {
    throw GradleException("Cannot release from a non version controlled tree.")
  }
}

task createReleaseTag(type: CreateTag) {
  tag = { -> "${project.name}-${project.version}" }
  description = "Create release tag."
  group = 'Release'
  gitDir = project.file(project.rootProject.projectDir.path + "/.git")
  if (!gitDir.exists()) {
    throw GradleException("Cannot release from a non version controlled tree.")
  }
}

task checkNoSnapshotDependencies(type: CheckConfiguration) {
  configuration = configurations.compile
}

task releaseMinor(type: CreateTag) {
  group = 'Release'
  description = "Build current version, upload it, tag it."
  gitDir = project.file(project.rootProject.projectDir.path + "/.git")
  tag = { -> "${project.name}-${project.version}" }

  // distribution task must be configurable since it's named differently in deployit/package project
  dependsOn build, distribution
  // before building distribution hook up the check tasks
  distribution.dependsOn checkReleaseTagIsAbsent, checkRepositoryIsClean //, checkNoSnapshotDependencies

  doFirst {
    // could do repo clean check also in doFirst, has benefit that we can do all the checks and then abort
    // in stead of failing at the first check task
  }
  doLast {
    def vps = versionProps.version.split('\\.')
    def minor = vps[2] as int
    minor++
    vps[2] = minor as String
    versionProps.version = vps.join('.')
    file('version.properties').withWriter  { w ->
      versionProps.store(w, 'version info')
    }
    def pass = project.getProperty('gitPassword')
    CredentialsProvider cp = new CredentialsProvider() {
      public boolean supports(CredentialItem... items) {
        return true;
      }
      public boolean isInteractive() {
        return false;
      }
      public boolean get(URIish uri, CredentialItem... items) throws UnsupportedCredentialItem {
        items.each {
          if (it instanceof CredentialItem.StringType) {
            CredentialItem.StringType st = (CredentialItem.StringType) it
            // logger.debug("CredentialItem promptText: '${st.promptText}'")
            st.setValue(pass);
          }
        }
        return true;
      }
    }
    FileRepository repo = new FileRepositoryBuilder().setGitDir(gitDir).build()
    def git = new Git(repo)
    git.add().addFilepattern('version.properties').call();
    git.commit().setMessage(tag.toString()).call();
    git.push().setCredentialsProvider(cp).setPushTags().call();
  }
}

import org.eclipse.jgit.errors.UnsupportedCredentialItem
import org.eclipse.jgit.transport.*
import org.eclipse.jgit.api.Git
import org.eclipse.jgit.lib.Repository
import org.eclipse.jgit.lib.Ref
import org.eclipse.jgit.storage.file.FileRepository
import org.eclipse.jgit.storage.file.FileRepositoryBuilder
import org.gradle.api.DefaultTask
import org.gradle.api.tasks.TaskAction

class CheckRepoClean extends DefaultTask {
  File gitDir
  boolean dryRun = false

  @TaskAction
  def checkClean() {
    // TODO repo needs close call in finally ? Would that work with the groovy with construct ?
    FileRepository repo = new FileRepositoryBuilder().setGitDir(gitDir).build()

    def status = new Git(repo).status().call()
    if (!status.isClean()) {
      if(dryRun) {
        println("The repo ${repo} is not clean. Please commit all changes before doing a release.")
      } else {
        throw new IllegalStateException("The repo ${repo} is not clean. Please commit all changes before doing a release.")
      }
    }
  }
}

class CheckTagAbsent extends DefaultTask {
  File gitDir
  def tag

  @TaskAction
  def checkClean() {
    println "Checking for absence of tag $tag"
    Repository repo = new FileRepositoryBuilder().setGitDir(gitDir).build()
    try {
      List<Ref> call = new Git(repo).tagList().call();
      for (Ref ref : call) {
        println "Checking tag name=${ref.name} objId=${ref.objectId.name}"
        if(ref.name == "${tag}") { // using gstring interpolation so a closure will work
          throw GradleException("Tag '${tag}' already exists. Aborting.")
        }
      }
    } finally {
      repo.close();
    }
  }
}

class CreateTag extends DefaultTask {
  File gitDir
  def tag

  @TaskAction
  def checkClean() {
    println "Creating tag $tag"
    Repository repo = new FileRepositoryBuilder().setGitDir(gitDir).build()
    Git git = new Git(repo)
    try {
      git.tag().setName("$tag").call();
    } finally {
      repo.close();
    }
  }
}

class CheckConfiguration extends DefaultTask {
  // TODO do we need a list of configurations compile + distBundle ?
  Configuration configuration

  @TaskAction
  def checkArtifacts() {
    logger.info("Checking configuration $configuration")
    int errors = 0
    configuration.resolvedConfiguration.resolvedArtifacts.each { ResolvedArtifact artifact ->
      def version = artifact.moduleVersion.id.version
      def name = artifact.moduleVersion.id.name
      def group = artifact.moduleVersion.id.group
      // println "Checking $name:$version"
      // TODO this should be configurable maybe list of Patterns depending on the release task
      if( version ==~ /.*alpha.*/ || version ==~ /.*SNAPSHOT.*/ ) {
        errors++
        // TODO include classifier (and more ?)
        logger.error("Found non release dependency ${group}:${name}:${version}")
      }
    }
    if(errors > 0) {
      throw new GradleException("Invalid artifact dependencies found")
    }
  }
}

import org.eclipse.jgit.api.Git
import org.eclipse.jgit.storage.file.FileRepository
import org.slf4j.Logger
import org.slf4j.LoggerFactory

class ReleasePluginPlugin implements Plugin<Project> {
    private static final Logger log = LoggerFactory.getLogger(ReleasePluginPlugin.class)

    enum ReleaseVersion { ALPHA, BETA, RELEASE }

    private Git repo
    private String versionString
    private Project rootProject
    private ReleaseVersion releaseVersion

    @Override
    void apply(Project project) {
        log.warn("Applying ReleasePluginPlugin to " + project.name)
        if (!project.tasks.names.containsAll(["clean", "build", "uploadArchives", "uploadDocumentation"])) {
            println "Cannot apply releases-plugin to " + project.name +
                    ": tasks [clean, build, uploadArchives, uploadDocumentation] must all be present"
            return
        }

        def release_task = project.rootProject.tasks.create("release")
        release_task.configure {
            this.rootProject = project.rootProject
            this.releaseVersion =
                    project.hasProperty("alpha") ? ReleaseVersion.ALPHA :
                    project.hasProperty("beta") ? ReleaseVersion.BETA :
                    project.hasProperty("final") ? ReleaseVersion.RELEASE :
                    null
            log.info("Release version ${releaseVersion} requested")
            release_task.doLast {
                if (!releaseVersion) {
                    println "What kind of release do you want? Please specify -Palpha, -Pbeta, or -Pfinal"
                    return
                }
                log.warn("releaseVersion: ${releaseVersion.name()}")
                doRelease()
            }
        }
    }

    def doRelease() {
        def rootDir = this.rootProject.rootDir
        log.warn("Using git repo at ${rootDir}")
        repo = Git.open(rootDir)
        ensureCleanRepo()
        gitPullRebase()
        setProjectVersion()
        doUpload project
        gitCommitAndTagReleasedVersion()
        bumpProjectVersion()
        gitCommitNextVersion()
        gitPush()
    }

    def ensureCleanRepo() {
        if (!(repo.status().call().clean)) {
            throw new GradleException("You have outstanding work. Please commit or stash before releasing.")
        }
    }

    def gitPullRebase() {
        try {
            repo.pull().setRebase(true).call()
        } catch (Exception e) {
            throw new GradleException("git pull --rebase failed", e)
        }
    }

    def setProjectVersion() {
        // TODO!
        // this.versionString = sump'n'sump'n'.
    }

    def doUpload() {
        this.rootProject.task("clean").execute()
        this.rootProject.task("build").execute()
        this.rootProject.task("uploadArchives").execute()
        this.rootProject.task("uploadDocumentation").execute()
    }

    def gitCommitAndTagReleasedVersion(Git repo) {
        def version = "${this.rootProject.name}-${versionString}"
        try {
            repo.commit().setMessage("Releasing ${version}").call()
            repo.tag().setMessage(version)
        } catch(Exception e) {
            throw new GradleException("git commit or git tag failed", e)
        }
    }

    def bumpProjectVersion() {
        // TODO!
    }

    def gitCommitNextVersion() {

    }
}

apply plugin: ReleasePluginPlugin